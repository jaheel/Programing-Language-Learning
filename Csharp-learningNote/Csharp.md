## 关键字

|                                                              |                                                              |                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract) | [as](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/as) | [base](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/base) | [bool](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/bool) |
| [break](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/break) | [byte](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/byte) | [case](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch) | [catch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch) |
| [char](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/char) | [checked](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/checked) | [class](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/class) | [const](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/const) |
| [continue](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/continue) | [decimal](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/decimal) | [default](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/default) | [delegate](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/delegate) |
| [do](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/do) | [double](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/double) | [else](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/if-else) | [enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum) |
| [event](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event) | [explicit](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/explicit) | [extern](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern) | [false](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/false) |
| [finally](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-finally) | [fixed](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/fixed-statement) | [float](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/float) | [for](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/for) |
| [foreach](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/foreach-in) | [goto](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/goto) | [if](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/if-else) | [implicit](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/implicit) |
| [in](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in) | [int](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/int) | [interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface) | [internal](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/internal) |
| [is](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/is) | [lock](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/lock-statement) | [long](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/long) | [namespace](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/namespace) |
| [new](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new) | [null](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/null) | [object](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/object) | [operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/operator) |
| [out](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out) | [override](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/override) | [params](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/params) | [private](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private) |
| [protected](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected) | [public](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/public) | [readonly](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly) | [ref](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref) |
| [return](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/return) | [sbyte](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sbyte) | [sealed](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed) | [short](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/short) |
| [sizeof](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sizeof) | [stackalloc](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/stackalloc) | [static](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static) | [string](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/string) |
| [struct](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/struct) | [switch](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch) | [this](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this) | [throw](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/throw) |
| [true](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/true) | [try](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/try-catch) | [typeof](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/typeof) | [uint](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/uint) |
| [ulong](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ulong) | [unchecked](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unchecked) | [unsafe](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe) | [ushort](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ushort) |
| [using](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using) | [using static](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-static) | [virtual](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual) | [void](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/void) |
| [volatile](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile) | [while](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/while) |                                                              |                                                              |

上下文关键字
|                                                              |                                                              |                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [add](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/add) | [alias](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern-alias) | [ascending](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ascending) |
| [async](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async) | [await](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/await) | [by](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/by) |
| [descending](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/descending) | [dynamic](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/dynamic) | [equals](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/equals) |
| [from](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/from-clause) | [get](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get) | [global](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/global) |
| [group](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/group-clause) | [into](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/into) | [join](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/join-clause) |
| [let](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/let-clause) | [nameof](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/nameof) | [on](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/on) |
| [orderby](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/orderby-clause) | [partial (type)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/partial-type) | [partial (method)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/partial-method) |
| [remove](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/remove) | [select](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/select-clause) | [set](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/set) |
| [value](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value) | [var](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var) | [when (filter condition)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/when) |
| [where (generic type constraint)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/where-generic-type-constraint) | [where (query clause)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/where-clause) | [yield](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield) |

## GUID

globally unique identifier全局唯一标识符

UUID universally

32个16进制数，{8-4-4-4-12}，128位二进制数

在 Windows 平台上，GUID 应用非常广泛：注册表、类及接口标识、数据库、甚至自动生成的机器名、目录名等。

## .NET Framework

CLR公共语言运行时(Common Language Runtime)

CLI公共语言基础架构(Common language Infrastructure)

FCL框架类库(Framework Class Library)

BCL基础类库(Base Class Library)

CLS公共语言规范(Common Language Specification)

CTS公共类型系统(Common Type System)

CIL公共中间语言(Common Intermediate Language)

托管代码 --> CIL -CLR-> 机器代码

![img](assets/2010012620512419.png)

## 内存管理与垃圾回收

值类型、引用类型、指针、指令

### 栈与堆

#### 线程栈

自动管理内存，使用完的自动清理

值类型和指针可放在栈里

#### 托管堆

需要控制垃圾回收GC

引用类型一定放在堆里，其相应的指针可放在栈里

### 垃圾回收

Garbage Collection

删除堆里主程序不会访问的对象，并重新分配剩余对象的内存空间，同时调整指针，非常耗费资源

## 数据类型

### 简单类型

-   整数

| 有符号 | 无符号 | size         |
| ------ | ------ | ------------ |
| sbyte  | byte   | 8bit,200     |
| short  | ushort | 16bit,6w     |
| int    | uint   | 32bit,42e    |
| long   | ulong  | 64bit,1800ee |

-   实数

| 类型    | 精度            | 范围 |
| ------- | --------------- | ---- |
| float   | 32bit, 7位      | 38   |
| double  | 64bit, 15-16位  | 308  |
| decimal | 128bit, 28-29位 | 28   |

> 0.0F 0.0D 0.0M
>
> 默认double，后缀f转换
>
> float与double类型转换时值会变化?
>
> decimal精度更高

-   布尔bool
-   字符char

### 更多类型

-   字符串string

-   对象object

> object为所有类的基类

-   隐式声明var[匿名类型](#匿名类型)
-   自定义类型

[类型默认值](<https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/default-values-table>)

### 引用类型与值类型

#### 值类型

System.ValueType

简单类型、枚举类型、结构类型、以上类型的可空类型

存储在声明时所在的堆或栈里

#### 引用类型

System.Object

string、object、自定义类、接口类型、数组类型、委托类型

引用类型默认为null

存储在堆里，并在栈上存储相应的指针

#### 装箱与拆箱

##### 装箱

值类型转化为引用类型时发生

需要在堆中分配内存并拷贝数据再返回地址，影响性能

##### 拆箱

引用类型转化为值类型时发生，严格意义拆箱指获取数据的地址

直接将堆中的数据拷贝到栈上

#### 指针

指针由CLR管理，不直接使用

指针占用一小块内存，存放另一块内存的地址

## 变量

> 声明，标识符，赋值，初始化(new)

### 文法

| 类型         | 示例                 |
| ------------ | -------------------- |
| 布尔型，整型 | true, false 0x, u, L |
| 实数型       | 6.02e+23, f,d,m      |
| 字符型       | '\uXXX'              |
| 字符串型     | @"""Hello"""         |
| 空型         | int?, null           |

## 运算符与表达式

> 操作数（运算符参数）

| 分类       | 运算符                             |
| ---------- | ---------------------------------- |
| 算术       | + - * / ++ -- %                    |
| 逻辑       | && \|\| ^ !                        |
| 比较       | > < >= <= == !=                    |
| 二项       | & \| ^ ~ << >>                     |
| 赋值       | = += -= *= /= %= $= \|= ^= <<= >>= |
| 类型转换   | is as typeof                       |
| 其他       | . [] () ?: new ??                  |
| 字符串连接 | +                                  |

### 算术

> a++ 与 ++a
>
> 0/0 异常 0.0/0.0 NaN （NaN出现在浮点数运算中）
>
> 整数溢出 checked

### 逻辑

> ^ 相同为false，不同为true

### 位运算符(bitwise)

> 对整数二进制逐位计算

11111100=252=-4

11111111=-1

0=256 

### 其他

> 字符串连接符第二个操作数自动转为字符串
>
> 赋值运算符返回值，右优先
>
> typeof(int)
>
> new int()
>
> (int)a

### 类型转换

> 显式与隐式
>
> 小转大可直接隐式

## 输入与输出

```c#
Console.
    Read() //输入字符，类型为int
    ReadKey() //ConsoleKeyInfo类型
    	.KeyChar
    	.Modifier
    ReadLine() //类型string，结束字符为null
    Write() //不换行
    WriteLine()
```

[Console.ReadKey()方法](https://msdn.microsoft.com/zh-cn/magazine/471w8d85(v=vs.100))

### 字符串转换为数字 

```c#
[int,float,long,...].Parse(string)
Convert
	.ToInt32()
	.ToSingle()
	.ToInt64()
char.ToString() // 字符转化为字符串
```

错误处理

```c#
int.TryParse(str_var, out int_var) //返回bool
```

### 其他

控制台输出编码

```c#
using System.Text
Console.OutputEncoding = Encoding.UTF8
```

[unicode与utf8](https://blog.csdn.net/xiaolei1021/article/details/52093706/)

小数分离式

![833F1737-28A7-4B50-91B9-AB0A7E522E25](assets/833F1737-28A7-4B50-91B9-AB0A7E522E25.jpg)



### 练习

[Thread线程](https://www.cnblogs.com/Peter-Luo/p/Threading.html)

[贪吃蛇](https://www.cnblogs.com/mingjiatang/p/4915346.html)

[String, StringBuilder, StringBuffer](https://www.cnblogs.com/su-feng/p/6659064.html)

[随机数](https://www.cnblogs.com/jackcheblog/p/7417632.html)

## 条件语句

> 条件不能是整数变量

```c#
if(){}
if(){}else{}
if(){ if(){}else{} }else{}
if(){}else if(){}else{}
switch(var)
{
    case value1: statement; break;
    case value2: statement; break;
    ...
    default: statement; break;
}
```

> switch-case多标签同一语句

```c#
case 1:
case 2:
	statement;
	break;
```

## 循环

```c#
while()do{}
do{}while();
for(initialization; test; update){} // 可多个计数变量
foreach(Type element in collection){} // element不能赋值
// collention元素需都为type（通过object类型可解决）
```

> 大整数 无法直接赋值整数，需用字符串转换

```c#
using System.Numerics;
string a = "12761985918349187364198237469182549128";
BigInteger i = BigInteger.Parse(a);
```

> goto语句退出外部循环

```c#
for()
{
    for()
    {
        goto breakOut;
    }
}
breakOut:;
```

## 数组

固定长度

```c#
new int[5]; //初始化为{0,0,0,0,0,}
{1,2,3};
new int[]{1,2,3};
.Length
```

### 操作

> 访问、反转、赋值

### 可变大小数组List\<T\>

```c#
new List<T>(); //T为数组元素类型
.Add();
.AddRange(); // 添加一个IEnumerable集合，如数组
.Insert(index, T);
.Remove(T); // 删除第一个匹配项
.RemoveAt(index);  // 删除索引处对象
.Clear();
.Contains(T); // 确认是否包含T
.IndexOf(T); // 第一个匹配项索引
.Reverse();
.Sort();
.ToArray();
.TrimExcess(int); // 删除超出指定数目的元素
.Count;

// 复制
List<T> lis1 = new List<T>();
List<T> lis2 = new List<T>(lis1.ToArray());

List<T> lis2 = new List<T>();
lis1.ForEach(i => lis2.Add(i));
```

### 复制数组

```c#
int[] copyArray = (int[])array.Clone(); 
// array.Clone()为object[]类型，实际调用父类Array的Clone()方法
```

### 多维数组

```c#
int[,]
string[,,]
new int[3,4]
{
	{1,2,3,4},
	{5,6,7,8},
}
.GetLength() //0为行，1为列
.Length // 所有元素个数
```

#### 操作

> 访问，读取，打印

```c#
String.Join("", str_array); //数组到字符串
```

### Jagged Array 交错数组

数组的数组

```c#
int[][] jagged = new int[3][];
jagged[0] = new int[3];
jagged[1] = new int[2];
jagged[2] = new int[5];
```

需要初始化每个数组

### Array类

所有数组类的父类

重要属性与方法

```c#
Array
    .Rank
    .Lenghth
    .GetLength()
    .GetEnumerator()
    .BinarySearch()
    .IndexOf()
    .LastIndexOf()
    .Copy(str,dest,len) // 静态方法
    .Clone() // 浅拷贝，实例方法
    .Reverse()
    .Clear()
    .CreateInstance()
```

#### 排序

```c#
Array.Sort(array[,IComparer(Comparison<T>)])
(a,b) => a.CompareTo(b);
```

使用$IComparer$类和$\lambda$ 表达式

#### 二分查找

```c#
Array.BinarySearch(array, object); //返回索引，没找到返回负数
```

## 数字系统

十进制、二进制、十六进制互相转换

整数表示

浮点数表示

文字表示

## 方法

函数、过程、子程序

**写在class下**

```Main()```也是一个方法，是程序的入口，一定是private static

参数声明可带默认值

方法签名=方法名称+参数

### 按引用传递参数

ref/out/in

```c#
void Method(ref/out/in int referenceParam)
{
    referenceParam += 1;
}

static void Main()
{
    int number = 1;
    Method(ref/out/in number);
}
```



### 返回值

return语句 

void返回```return;```

### 方法重载

用同样的名称，不同的参数实现多个方法

### 可变数量的参数

```params```关键字

```c#
static void Func(params int[] elements)

Func(1,2,3,6);
```

## 递归

方法调用自己

***递归与栈***

### 示例

阶乘、*创建0/1向量*、迷宫路径

快速斐波那契

## 命名空间

```c#
using Namespace;
namespace name
{
    
}
```



## 类和结构

类class是引用类型，结构struct是值类型

struct通常用于小型变量组的封装

对象即实例

### 字段、属性

field字段，成员变量

get访问器和set访问器

```c#
private string name;
public string Name //属性Name
{
    get{ return name;}
    set{ name = value;}
}
```

>   封装、实现更多的取值和赋值、字段安全

### 实例与静态成员

instance.name

class.name

### 方法，构造函数

实例方法与静态方法

```c#
//构造函数
class Person
{
    Person() //默认public
    {
    }
}
// 构造函数可以有多个，获得的参数不同
```

静态构造函数初始化静态成员

### 枚举

```c#
enum <enum_name>
{
    element1, element2, ... 
};
```

列表中每个符号代表一个整数值，默认从0开始

默认为int，可以为char以外的任何整型

```c#
enum Day {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
Day day = Day.Sun;
string d = day.ToString(); // d = "Sun"
int dd = (int)d; // dd = 0

enum Enum : long {};

enum Enum {x = 1, y = 8, z = 11};
```

值类型

## 异常

基于过程：每个函数返回错误代码

基于对象：异常是类

### 处理异常

try-catch-finally

```c#
try{}
catch(SomeException){}
...
catch(){}
```

不处理的异常引起错误消息

### System.Exception

#### 异常属性

>   Message 文本描述
>
>   StackTrace 快照
>
>   InnerException 引起当前异常的异常

```c#
catch(SomeException e){...e.Message...e.StackTrace...}
```

### 异常层级

-   System.Exception
    -   System.SystemException
        -   System.ArgumentException
        -   System.NullReferenceException
        -   System.OutOfMemoryException
        -   System.StackOverflowException
        -   System.FormatException
        -   System.ArithmeticException
            -   System.DivideByZeroException
            -   System.OverflowException
    -   System.ApplicationException

==捕捉异常后，所有子异常也被捕捉，无法再次捕捉==

.NET托管代码？

托管代码继承自System.Exception，非托管代码能抛出其他异常

处理所有异常

```c#
try{}
catch{}
```

### 抛出异常

```c#
throw new ArgumentException("message")
```

异常接受消息与原因

```c#
try{}
catch(FormatException e)
{
    throw new ArgumentException("message", e);
}
```

重新抛出异常

```c#
try{}
catch(SomeException e)
{
    throw e;
//  throw;  抛出最后捕捉的异常
}
```

### 选择异常

#### 无效参数

ArgumentException

ArgumentNullException

ArgumentOutOfRangeException

#### 运算符不支持

NotSupportedException

#### 方法没有实现

NotImplementedException

#### 没有标准异常类，自己创建

### try-finally

```c#
try{}
finally{}
```

### 最佳实践

-   catch块从最低层次开始

-   只处理期望异常
-   引起异常传递良好的解释消息？
-   抛出异常传递良好的问题描述？
-   只在真正有异常并需要处理时

## 字符串与文本

引用类型，只读

```c#
String.Length
str[n] // 为char类型
```

### 声明

```c#
string str1; // 关键字
System.String str2; //类全名
String str3; //类名
```

### 创建

==引用类型默认值为null==

### 读取与打印

### 比较

```c#
string.Compare(str1, str2, true) // 字典序，第三个参数控制是否大小写不敏感
```

| 前   | str2 | 后   |
| ---- | ---- | ---- |
| -1   | 0    | 1    |

```c#
str1 == str2; // 大小写敏感
str1.Equals(str2); // 大小写敏感
```

### 操作

字符串不可改变，任意操作都生成新字符串

#### 连接

```c#
String.Concat(str1, str2);
str1 + str2;
name + 22; // 任何对象都能够加入
```

#### 搜索

```c#
str.IndexOf(string str[, int startIndex]); // -1为没有找到
str.LastInexOf(string str);
```

#### 分片(子字符串)

```c#
str.Substring(int startIndex[, int length]);
```

#### 分隔

```c#
str.Split(params char[]);
```

#### 替换

```c#
str.Replace(str1, str2);
```

#### 删除

```c#
str.Remove(startIndex[, length])
```

#### 其他

```c#
str.ToUpper();
str.ToLower();
str.Trim([params char[]]);
str.TrimStart();
str.TrimEnd();
Char.IsUpper(char);

```

### StringBuilder

有缓冲内存，可直接使用，不需分配新对象

解决string重复增加的低效率

```c#
StringBuilder([int capacity]) //构造函数，默认16字符
stringbuilder
	.Capacity // 分配空间
	[n] // 索引访问
	.Length // 字符长度
	.Append()
    .Remove(index, length)
    .Insert(index, str)
    .Replace(strold, strnew)
    .ToString() // 转换为String
```

### 格式化

#### ToString()

所有类都有的public virtual方法

class.Parse() 解析字符串

```c#
var.ToString(formatString)
formatString
	Dn // 数字
	C // 货币
	E // 科学计数法
	Pn // 百分数
	X // 十六进制数
	F // 固定浮点
	N // 逗号分隔千位
```

#### String.Format()

[模板格式化](<https://www.cnblogs.com/FlyingBread/archive/2007/01/18/620287.html>)

占位符

```c#
{index[,alignment][:formatString]}
str.PadLeft(n, char)
str.PadRight(n, char) // 自定义填充字符
```

DateTime日期格式化

```c#
d, dd // 日
M, MM // 月
yy, yyyy // 年
h, HH, m, mm, s, ss // 时分秒
{index:DateTimeformatString}
```

#### 文化

```c#
System.Threading.Tread.CurrentTread.CurrentCulture;
CultureInfo; //类，如"zh-CN, en-CA"
number.ToString("C", culture); // culture为CultureInfo类
```

## 定义类

-   特性attribute
    -   状态，属性property，字段
-   行为
    -   方法，操作



-   成员

    -   字段，常量？，方法，属性，索引器，事件，运算符，构造函数，析构函数，...

    -   内部结构

        -   内部类

        -   结构体

        -   接口

        -   ###### 代理，……

### 访问修饰符

public

private 只能被这个类访问

protected 这个类和其子类可以访问

internal(default) 当前程序集可访问

```
程序集即一个项目的实现，一个应用程序、类库、控制台等的所有代码，体现为exe或dll文件
多个项目组成一个解决方案
```

this关键字

static 静态类型，类固有成员，可通过类名直接调用

virtual 父类成员修饰，需要能具体实现，子类可以不用重写

abstract 父类成员修饰，==一定不能具体实现== ，子类必须重写

```
virtual可以修饰方法、属性、索引器、事件签名（不能修饰类）
abstract可以修饰类、方法、属性、索引器、事件
abstract成员必须在abstract类中
abstract类可以有非abstract成员
父类成员必须为public或protected，子类重写时须保持一致
```

override 子类方法重写修饰

>   理解：virtual是为了能够使用override重写，abstract是为了定义一个模板从而实现有相似功能的子类

### 构造函数

无返回类型

和类同名

构造函数应初始化所有字段

非public构造函数？

重用构造函数进行默认初始化

```c#
public class Point
{
    private int x;
    private int y;
    public Point() : this(0,0)
    {
    }
    
    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}
```

### 终结函数

析构函数

被垃圾回收器自动调用

```c#
~Point()
{
    // cleanup statements...
}

GC.SuppressFinalize(this); // 不再自动调用终结器
```

### 属性

getter， setter

```c#
public class Point
{
    private int x;
    public int X
    {
        get{return this.x;}
        set{this.x = value;}
    }
}
```

属性不绑定字段，可自由创建

可以不需要任何字段，编译器自动创建

### 保持对象状态正确

构造函数和属性可以保证状态正确，如初始参数、赋值的正确性等。

### 静态成员

与实例无关

可用于：

-   字段
-   属性
-   方法
-   事件
-   构造函数?

### 结构体

定义继承自System.ValueType的值类型对象

字段，属性，方法，构造函数，事件

### 泛型

```c#
public class GenericList<T>
{
	public void Method(T x){}
}
```

## 接口Interface

与抽象类类似，接口提供派生类应遵循的标准结构

==接口定义属性、方法、事件，不能有字段、构造函数==

接口及其成员不需要修饰符，默认public

```c#
interface IParentInterface
{
    void ParentMethod();
}
interface IMyInterface : IParentInterface // 接口继承
{
    void Method();
}
class InterfaceImplement : IMyInterface
{
	public void ParentMethod()
    {
    }
    
	public void Method()
    {
    }
}
```

### 接口与抽象类的区别

接口用于规范，抽象类用于共性

抽象类是类，单继承?

>   接口用于规范，抽象类用于共性。抽象类是类，所以只能被单继承，但是接口却可以一次实现多个。
>
>   接口中只能声明方法，属性，事件，索引器。而抽象类中可以有方法的实现，也可以定义非静态的类变量。
>
>   抽象类可以提供某些方法的部分实现，接口不可以。抽象类的实例是它的子类给出的。接口的实例是实现接口的类给出的。
>
>   在抽象类中加入一个方法，那么它的子类就同时有了这个方法。而在接口中加入新的方法，那么实现它的类就要重新编写（这就是为什么说接口是一个类的规范了）。
>
>   接口成员被定义为公共的，但抽象类的成员也可以是私有的、受保护的、内部的或受保护的内部成员（其中受保护的内部成员只能在应用程序的代码或派生类中访问）。
>
>   此外接口不能包含字段、构造函数、析构函数、静态成员或常量。
>
>   还有一点，我们在VS中实现接口时会发现有2个选项，一个是实现接口，一个是显示实现接口。实现接口就是我们平常理解的实现接口，而显示实现接口的话，实现的方法是属于接口的，而不是属于实现类的。

### IEnumerator

```c#
interface IEnumerable
{
    IEnumerator GetEnumerator(); // 此方法返回一个IEnumerator
}
interface IEnumerator
{
    object Current{get;}
    bool MoveNext();
    void Reset();
}
```

foreach遍历需要实现IEnumerable

## 委托与事件

委托：对方法的引用，类似指针

面向对象，类型安全

事件（委托）类型

事件（委托）变量

事件（委托）处理器

```c#
delegate int MyDelegate(int x);
public int Method(int x){}; // 要引用的方法的标签要和委托相同，即参数类型和返回类型
MyDelegate dg = new MyDelegate(Method);
```

发布器-订阅器

事件基于委托

实现线程间的通信

```c#
public class Publisher
{
    public delegate int MyDelegate(); // 定义委托，相当于创建一个委托的嵌套类
    public event MyDelegate MyEvent; // 创建一个委托实例，使用event关键字做保护
    public void MethodP() // 调用此方法即发生事件，通过委托在其他对象中响应此事件
    {
        MyEvent();
    }
}

public class Subcriber
{
    public int MethodS()
    {
    }
}

public class Program
{
    static void Main()
    {
        Publisher p = new Publisher();
        Subcriber s = new Subcriber();
        p.MyEvent = new Publisher.MyDelegate(s.MethodS);
        p.MethodP(); // 实际执行s.MethodS()
    }
}
```

标准事件

```c#
class SampleEventArgs : EventArgs
{
	SampleEventArgs(int arg)
	{
		eventArg = arg;
	}
    public int eventArg{ get; set;}
}

class Publisher
{
    public delegate void SampleEventHandler(object sender, SampleEventArgs e);
    public event SampleEventHandler SampleEvent;
    
    private void RaiseSampleEvent()
    {
        if(SampleEvent != null)
        {
            SampleEvent(this, new SampleEventArgs(1))
        }
    }
}

// 在别处执行
// SampleEvent += SomeMethod;
```

事件访问器

```c#
EventHandlerList events = new EventHandlerList();
public event SampleEventHandler SampleEvent
{
	add
	{
		events.AddHandler(null, value);
	}
	remove
	{
		events.RemoveHandler(null, value);
	}
}
```



## 流

### 流Stream

读写二进制(字节)数据

打开后要关闭

### 序列化

将数据(结构)转变为流

反序列化

### StreamReader

```c#
new StreamReader(filename, encoding);
.ReadLine(); // 不读取换行符
.ReadToEnd();
.Close(); // 一定要关闭，否则资源丢失

// 编码encoding
System.Text.Encoding;
Encoding.GetEncoding("gb2312"); // UTF-8

// 更好的方式，自动关闭，类似python with上下文结构，下同
using (<stream object>)
{
    
}
```

### StreamWriter

```c#
new StreamWriter(filename, bool, encoding);
.Write();
.WriteLine(); // 自动添加换行符
.Flush(); // 缓冲区刷新
.AutoFlush; // bool类型
```

### 异常

```c#
System.IO.FileNotFoundException;
System.NullReferenceException; // 读取null对象内容
```

## 数据结构

### 线性数据结构

列表、栈、队列

List\<T\>

Stack\<T\>

```c#
.Push(T);
.Pop();
.Peek(); // 回栈顶不删除
.Count;
.Clear();
.Contains(T);
.ToArray();
.TrimExcess();
```

Queue\<T\>

```c#
.Enqueue(T);
.Dequeue();
.Peek();
.Count;
.Clear();
.Contains(T);
.ToArray();
.TrimExcess();
```

优先队列

OrderedBag<T>

### 树

二叉搜索树：左子树$\leq$节点$\leq$右子树     

平衡二叉树： 空树或左右子树高度差不超过1

>   平衡数增加搜索删除的复杂度为$O(\log(n))$

红黑树：自平衡二叉搜索树

堆

#### 遍历

DFS：递归，栈

```c#
DFS(node)
{
    foreach(child in node) DFS(child); // 递归访问子节点
    print node;
}
```

BFS：队列

##### 二叉树DFS

先根序，中根序，后根序

#### 平衡二叉搜索树

高度$\log_2(n)$ 

搜索复杂度$log_2(n)$ 

>   难以实现，平衡复杂

##### B树

度order : d

键key = 子节点数 - 1，范围d~2d

键的数目超出范围时将产生合并节点或拆分节点来实现平衡

插入

```
1.插入应在位置节点
2.超出范围，找中位数，分裂，中位数进入父节点
3.递归，若导致父节点分裂，则全部深度加一
```

删除

```
两种方法，先删在调整，或调整到删除，下为第一种

1.删除元素
	1.叶节点
	2.内部节点，从子节点中选取一个放到删除元素的位置
2. 下溢出平衡
	1) 若右兄弟有多余元素，向左补全位置
	2）若左兄弟有多余元素，向右补全位置
	3）若都没有多于元素，和其中之一合并
        1. 合并后若父节点下溢出，则递归
```

B+，B*

##### AVL树

##### 红黑树

```
节点红或黑
根黑叶子黑
红有两黑子
叶路径同黑
```



SortedDictinary<K,V> 基于键值对映射

OrderedSet\<T\> 基于元素集合

##### AA树

#### 图

临接列表

邻接矩阵

边集合

图遍历

### 字典

接口IDictionary\<TKey, TValue\> 

```c#
IDictionary<TKey, TValue> dict = new Dictionary<TKey, TValue>();
IDictionary<TKey, TValue> dict = new SortedDictionary<TKey, TValue>();
```



#### Dictionary\<TKey, TValue\>

哈希函数通过关键字确定元素地址

哈希函数$f()$

关键字$k$

元素地址$f(k)$

冲突处理

##### Dictionary\<TKey, TValue\>

哈希表实现字典

随即顺序，依赖Object.GetHashCode()与Object.Equals()

```c#
Dictionnary<TKey, TValue>
    .Add(TKey, TValue);
    .Remove(TKey);
    this[];
    .Clear();
    .Count;
    .Keys;
    .Values;
    .ContainsKey(TKey);
    .ContainsValue(TValue); // 缓慢
    .TryGetValue(TKey, out TValue);
```

#### SortedDictionary\<TKey, TValue\>

自平衡搜索树实现

键排序

操作效率较低，$\log_2(n)$

#### 键比较

Dictionary<TKey, TValue>

​	Object.Equals()

​	Object.GetHashCode() // return int

SortedDictionary<TKey, TValue>

​	IComparable\<T\>

```c#
IComparable<T>
{
    public int CompareTo(T); // -1 | 0(T)| 1
}
```

如要使用需要先定义键比较的依赖对象

### 集合与包

无重复：集合

有重复：包Bag

```c#
Add(element);
Contains(element) -> true / false;
Delete(element);
Union(set) / Intersect(set); // 并集、交集
```

接口ISet\<T>

```
ISet<T> set = new HashSet<T>();
...
```

#### HashSet\<T\>

```
Add()
Remove()
Count
UnionWith()
IntersectWith()
```

#### OrderedSet\<T>

## 更多

### 扩展方法

静态类中、static、第一个参数前this

```c#
public static class Extentions
{
    public static int ExMethod(this string str){}
}
static void Main()
{
    string s;
    int i = s.ExMethod(); // 在string类型中增加了扩展方法ExMethod
}
```

### 匿名类型

```c#
var data = new {elem1 = data1, elem2 = data2};
data.elem1;
```

可以有不同的类型，自动生成唯一命名类，且不可见

属性只读

引用类型，直接派生自Object

重写了Equals(), GetHashCode(), ToString()

无==, !=

```c#
var arr = new[] {new{}, new{}};
var pets = new Pet[] {new Pet{}, new Pet{}};
```

### 匿名方法

```c#
class(params){}; // 不取名
```

### lambda表达式

lambda运算符=>

```c#
x => (x%2) == 0; // 返回bool

.FindAll(lambda expression);
.RemoveAll();
.OrderBy();
```

储存委托

标准函数委托

Func\<TResult>, Func\<T, TResult>, Func\<T1, T2, Result>, ...

```c#
Func<bool> booFunc = () => true; // 标准函数委托Func<TResult>
```

### LINQ查询关键字

```c#
select
from in
where
group
orderby
join in on equals

string[] numbers;
// 使用匿名类型存储查询结果
var nums = 
	from num in numbers
	where num < 5
    oderby num
	select num;
```

嵌套，排序

查询语法

方法语法

基于扩展方法和lanbda表达式

LINQ to OBJECTS

LINQ to SQL

LINQ to XML

## 数据结构与算法复杂度

## 面向对象

### 继承

父类、基类：定义特性和行为

接口：定义操作集合（空白方法与属性），不定义字段

派生类继承基类

类实现接口

派生接口扩展自基接口

实现is-a关系

不要实现has-a关系



一个类继承一个基类

一个类可实现多个接口

一个接口可扩展自多个接口



调用基类构造函数

```c#
public Point(int x, int y) : base(x)
{}
```

==派生类只能在方法或函数中调用基类成员==

static方法中不能用base调用基类成员

#### 修饰符

##### 访问修饰符

public

private

protected

internal

protected internal

private protected

类默认internal

类成员默认为private

构造函数默认为public

##### 其他修饰符

[static](https://www.cnblogs.com/xinaixia/p/5768148.html)

abstract

virtual

override

const

### 抽象

抽象类

接口

继承

### 封装

隐藏细节实现

### 多态

获得更多的能力

重写父类(abstract, virtual)或父接口行为

泛型

virtual虚方法，能够被重写override

### 内聚与耦合

中心目标

类要有强相关函数、单一目标

耦合：类或程序之间的联系

松耦合、强内聚

## 高质量编程

### 外部质量

输出正确

所有情况正确

良好测试

易于使用

运行流畅

### 内部质量

阅读与理解

良好构造

易于修改与维护

文档

格式

### 代码约定

[官方代码约定](https://msdn.microsoft.com/zh-cn/library/ms229042.aspx)

### 管理复杂度

### 代码格式化

### 高质量类

### 高质量方法

强内聚

只做方法名描述的事情

可接受内聚类型

-   函数式内聚
-   序列式内聚
-   通信式内聚
-   暂时性内聚

不可接受的内聚

-   逻辑内聚
-   巧合内聚

## 反射

System.Reflection

System.Reflection.Assembly

System.Type

获取程序集类型信息MemberInfo

运行时创建、调用和访问类型实例

优点：

-   反射提高了程序的灵活性和扩展性。
-   降低耦合性，提高自适应能力。
-   它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：

-   性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
-   使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

使用dynamic简化并优化反射

## 语法糖

属性

```c#
public string Property { get; private set; }
```

委托、[lambda表达式](#lambda表达式)

```c#
delegate void Del(string str);
Del del1 = delegate(string str){Console.WriteLine(str);}; // 匿名委托
Del del2 = str => Console.WriteLine(str); // lambda表达式委托
```

List

```c#
List<string> list = new List<string> { "firstString", "secondString"};
```

集合操作

```c#
list.ForEach(a => Console.WriteLine(a));
```

资源自动释放

```c#
using(){} // 与下方等价
try{}finally{Dispose();}
```

var

```c#
var variable = new Class(); // 只能用在局部变量，不能用于字段或参数声明
```

?

```c#
relationExpression(x, y) ? x : y;
x ?? y; // x为null返回y
```

实例化(省略构造函数)

```c#
var classA = new ClassA{ Prop1 = prop1, Prop2 = prop2};
```

[扩展方法](#扩展方法)

[匿名类](#匿名类型)